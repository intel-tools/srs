on:
  workflow_call:
    inputs:
      repo:
        description: 'repo'
        required: true
        default: ''
        type: string
      autoconf:
        description: 'autoconf'
        required: false
        default: ''
        type: string
      cmake:
        description: 'cmake'
        required: false
        default: ''
        type: string
      meson:
        description: 'meson'
        required: false
        default: ''
        type: string
jobs:
  scan-build:
    runs-on: ubuntu-latest

    container:
      image: ghcr.io/${{ github.actor }}/${{ github.repository }}.debian:latest
      credentials:
        username: ${{ github.actor }}
        password: ${{ secrets.GHPAT }}

    env:
      DEBIAN_FRONTEND: noninteractive
      LLVM_VERSION: "15"
      TIMEOUT: "10m"

    defaults:
      run:
        shell: bash

    steps:
      - name: generate save directory name
        id: vars
        run: |
          srepo=$(echo ${{ inputs.repo }} | tr '/' .)

          echo "SREPO set to ${SREPO}"
          echo "SREPO=$srepo" >> $GITHUB_OUTPUT

          echo "autoconf=${{ inputs.autoconf }}" >> $GITHUB_OUTPUT
          echo "meson=${{ inputs.meson }}" >> $GITHUB_OUTPUT
          echo "cmake=${{ inputs.cmake }}" >> $GITHUB_OUTPUT

      - name: checkout repo
        uses: actions/checkout@v3
        with:
          token: ${{ secrets.GHPAT }}
          repository: ${{ inputs.repo }}
          path: repo

      - name: check for autoconf setup scripts
        if: steps.vars.outputs.autoconf != ''
        timeout-minutes: 30
        run: |
          find_builddir() {
            local f=$1
            local dir=$(find . -iname "$f" -type f -printf '%h\n')
            for d in $dir; do
              if [ -z $(grep "$PWD/$d" $GITHUB_WORKSPACE/build_autoconf) ]; then
                s=$(find $dir -iname "$f" -type f | head -n1)
                echo "Found $s in $PWD/$d"
                echo "$PWD/$d $s" >> $GITHUB_WORKSPACE/build_autoconf
              fi
            done
          }

          cd $GITHUB_WORKSPACE/repo
          touch $GITHUB_WORKSPACE/build_this

          search=""
          search+=$(find_builddir "configure")
          search+=$(find_builddir "autogen.sh")
          search+=$(find_builddir "bootstrap.sh")
          search+=$(find_builddir "bootstrap")
          search+=$(find_builddir "boot")
          search+=$(find_builddir "buildconf")
          search+=$(find_builddir "configure.ac")

          echo "${search}"

          if [ -z "${search}" ]; then
            echo "Couldn't find any build directory!"
            exit 1
          fi

      - name: check for cmake setup scripts
        if: steps.vars.outputs.cmake != ''
        timeout-minutes: 30
        run: |
          find_builddir() {
            local f=$1
            local dir=$(find . -iname "$f" -type f -printf '%h\n')
            for d in $dir; do
              echo "Found $f in $PWD/$d"
              project=$(grep 'project(' ${d}/${f} | wc -l)
              if [ ${project} -gt 0 ]; then
                echo "Top level $f found at ${d}/${f}"
                echo "$PWD/$d $f" >> $GITHUB_WORKSPACE/build_cmake
              fi
            done
          }

          cd $GITHUB_WORKSPACE/repo

          search=""
          search+=$(find_builddir "CMakeLists.txt")

          echo "${search}"

          if [ -z "${search}" ]; then
            echo "Couldn't find any build directory!"
            exit 1
          fi

      - name: check for meson setup scripts
        if: steps.vars.outputs.meson != ''
        timeout-minutes: 30
        run: |
          find_builddir() {
            local f=$1
            local dir=$(find . -iname "$f" -type f -printf '%h\n')
            for d in $dir; do
              project=$(grep 'project(' "$d/$f" | wc -l)
              if [ $project -gt 0 ]; then
                echo "Found $f in $PWD/$d"
                echo "$PWD/$d $f" >> $GITHUB_WORKSPACE/build_meson
              fi
            done
          }

          cd $GITHUB_WORKSPACE/repo

          search=""
          search+=$(find_builddir "meson.build")

          echo "${search}"

          if [ -z "${search}" ]; then
            echo "Couldn't find any build directory!"
            exit 1
          fi


      - name: search and install repo dependencies
        timeout-minutes: 30
        run: |
          packages=""
          declare -a files=(
            $(grep -rl "apt-get install")
            $(grep -rl "apt install")
            $(grep -rl "aptitude install")
          )

          for r in "${files[@]}"; do
            found=0
            newline=0

            while read -r line; do
              if [ $(echo -n "${line}" | grep "apt-get install" | wc -l) -eq 1 ]; then
                found=1
              fi

              # found install line, grab all potential packages from this line plus lines after while there is linebreak 
              if [ $found -eq 1 ]; then
                if [ $newline -eq 0 ]; then
                  packages+=$(echo -n $line | sed -r 's/^.*install //' | sed -r 's/^;//' | sed 's/\\/ /g' | awk '{split($0,a," "); for (x in a) { if (a[x] ~ /^[^-].*$/) { printf("%s ", a[x]) } } }')
                else
                  packages+=$(echo -n $line | sed -r 's/^;//' | sed 's/\\/ /g' | awk '{split($0,a," "); for (x in a) { if (a[x] ~ /^[^-].*$/) { printf("%s ", a[x]) } } }')
                fi

                # check if there is a linebreak at the end
                if [ $(echo -n $line | awk '{print $NF}' | grep "\\\\" | wc -l) -eq 0 ]; then
                  newline=0
                  found=0
                else
                  newline=1
                fi
              fi
            done < $r
          done

          packages=$(echo -n $packages | tr -dc '[:alnum:]\-\_ ')

          for p in ${packages}; do
            apt-get -y install "${p}" || :
          done

      - name: try to checkout submodules but don't stall
        timeout-minutes: 30
        run: |
          cd repo
          git submodule update --init --recursive || :

      - name: scan-build AUTOCONF
        if: steps.vars.outputs.autoconf != ''
        timeout-minutes: 30
        env:
          SREPO: ${{ steps.vars.outputs.SREPO }}
        run: |
          export OUTPUT=$GITHUB_WORKSPACE/$SREPO

          set -o pipefail

          mkdir -p ${OUTPUT}

          while read -r build; do

            dir=$(echo $build | awk '{ print $1 }')
            script=$(echo $build | awk '{ print $2 }')

            cd $dir

            # don't scan the same folder multiple times
            if [ -f "scan-build-done" ]; then
              continue;
            fi

            echo "Scanning $dir with setup $script"

            case $script in
              configure.ac)
                autoreconf -vif
                ;;

              Configure)
                mv Configure configure
                ;;

              *)
                chmod +x ./$script
                ./$script
                ;;
            esac

            echo $dir >> ${OUTPUT}/scan-build-configure.log

            ./configure | tee -a ${OUTPUT}/configure.log 2>&1 || continue
            intercept-build-${LLVM_VERSION} make -j2 | tee -a ${OUTPUT}/make.log 2>&1 || continue

            timeout -s 2 ${TIMEOUT} \
            run-clang-tidy-${LLVM_VERSION} -quiet \
              -config="{Checks: 'readability-function-cognitive-complexity', CheckOptions: [{key: readability-function-cognitive-complexity.Threshold, value: 0}, {key: readability-function-cognitive-complexity.DescribeBasicIncrements, value: False}]}" \
              2>/dev/null | \
              grep warning | grep "cognitive complexity" | tee -a ${OUTPUT}/cognitive-complexity.log || :

            echo $dir >> ${OUTPUT}/scan-build.log

            timeout -s 2 ${TIMEOUT} \
            /usr/bin/time -p -o ${OUTPUT}/scan-build-time \
            analyze-build-${LLVM_VERSION} -v --cdb compile_commands.json --analyze-headers --keep-empty --force-analyze-debug-code --html-title ${{ inputs.repo }} -o ${OUTPUT}/scan-build-result \
              --analyzer-config crosscheck-with-z3=true \
              --disable-checker deadcode.DeadStores \
              --enable-checker security.FloatLoopCounter \
              --enable-checker security.insecureAPI.strcpy | tee -a ${OUTPUT}/analyze-build.log 2>&1 || continue

            t=$(cat $OUTPUT/scan-build-time | grep real | awk '{ print $2 }')
            echo "$dir $t" > $OUTPUT/time.log

            touch $dir/scan-build-done

          done < $GITHUB_WORKSPACE/build_autoconf

          if [ ! -d $OUTPUT/scan-build-result ]; then
            exit 10
          fi

      - name: scan-build CMAKE
        if: steps.vars.outputs.cmake != ''
        timeout-minutes: 30
        env:
          SREPO: ${{ steps.vars.outputs.SREPO }}
        run: |
          export OUTPUT=$GITHUB_WORKSPACE/$SREPO

          set -o pipefail

          mkdir -p ${OUTPUT}

          while read -r build; do

            dir=$(echo $build | awk '{ print $1 }')

            cd $dir

            # don't scan the same folder multiple times
            if [ -f "scan-build-done" ]; then
              continue;
            fi

            echo "Attempting to build $GITHUB_WORKSPACE/repo/$dir"

            mkdir -p $dir/build
            cd $dir/build

            echo $dir >> $OUTPUT/cmake.log

            cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=YES $dir | tee -a ${OUTPUT}/cmake.log 2>&1 || continue

            timeout -s 2 ${TIMEOUT} \
            run-clang-tidy-${LLVM_VERSION} -quiet \
              -config="{Checks: 'readability-function-cognitive-complexity', CheckOptions: [{key: readability-function-cognitive-complexity.Threshold, value: 0}, {key: readability-function-cognitive-complexity.DescribeBasicIncrements, value: False}]}" \
              2>/dev/null | \
              grep warning | grep "cognitive complexity" | tee -a ${OUTPUT}/cognitive-complexity.log || :

            echo $dir >> $OUTPUT/analyze-build.log

            timeout -s 2 ${TIMEOUT} \
            /usr/bin/time -p -o ${OUTPUT}/analyze-build-time \
            analyze-build-${LLVM_VERSION} -v --cdb compile_commands.json --analyze-headers --keep-empty --force-analyze-debug-code --html-title ${{ inputs.repo }} -o ${OUTPUT}/scan-build-result \
              --analyzer-config crosscheck-with-z3=true \
              --disable-checker deadcode.DeadStores \
              --enable-checker security.FloatLoopCounter \
              --enable-checker security.insecureAPI.strcpy | tee -a ${OUTPUT}/analyze-build.log 2>&1 || continue

            t=$(cat $OUTPUT/analyze-build-time | grep real | awk '{ print $2 }')
            echo "$dir $t" > $OUTPUT/time.log

            touch $dir/scan-build-done

          done < $GITHUB_WORKSPACE/build_cmake

          if [ ! -d $OUTPUT/scan-build-result ]; then
            exit 10
          fi

      - name: scan-build MESON
        if: steps.vars.outputs.meson != ''
        timeout-minutes: 30
        env:
          SREPO: ${{ steps.vars.outputs.SREPO }}
        run: |
          export OUTPUT=$GITHUB_WORKSPACE/$SREPO

          set -o pipefail

          mkdir -p ${OUTPUT}
          while read -r build; do

            dir=$(echo $build | awk '{ print $1 }')

            cd $dir

            # don't scan the same folder multiple times
            if [ -f "scan-build-done" ]; then
              continue;
            fi

            echo $dir >> ${OUTPUT}/meson-setup.log

            meson setup builddir --buildtype debug 2>&1 | tee -a $OUTPUT/meson-setup.log || continue

            cd builddir

            timeout -s 2 ${TIMEOUT} \
            run-clang-tidy-${LLVM_VERSION} -quiet \
              -config="{Checks: 'readability-function-cognitive-complexity', CheckOptions: [{key: readability-function-cognitive-complexity.Threshold, value: 0}, {key: readability-function-cognitive-complexity.DescribeBasicIncrements, value: False}]}" \
              2>/dev/null | \
              grep warning | grep "cognitive complexity" | tee -a ${OUTPUT}/cognitive-complexity.log || :

            echo $dir >> ${OUTPUT}/analyze-build.log

            timeout -s 2 ${TIMEOUT} \
            /usr/bin/time -p -o ${OUTPUT}/analyze-build-time \
            analyze-build-${LLVM_VERSION} -v --cdb compile_commands.json --analyze-headers --keep-empty --force-analyze-debug-code --html-title ${{ inputs.repo }} -o ${OUTPUT}/scan-build-result \
              --analyzer-config crosscheck-with-z3=true \
              --disable-checker deadcode.DeadStores \
              --enable-checker security.FloatLoopCounter \
              --enable-checker security.insecureAPI.strcpy | tee -a ${OUTPUT}/analyze-build.log 2>&1 || continue

            t=$(cat $OUTPUT/analyze-build-time | grep real | awk '{ print $2 }')
            echo "$dir $t" > $OUTPUT/time.log

            touch $dir/scan-build-done

          done < $GITHUB_WORKSPACE/build_meson

          if [ ! -d $OUTPUT/scan-build-result ]; then
            exit 10
          fi

      - name: generate json from scan-build html
        if: ${{ always() }}
        env:
          SREPO: ${{ steps.vars.outputs.SREPO }}
        run: |
          parse_info() {
            local f=$1
            local d=$2
            grep $d $f | awk -F "$d " '{ print $2 }' | rev | cut -c5- | rev
          }

          export OUTPUT=$GITHUB_WORKSPACE/$SREPO

          bugfound=0
          now=$(date)
          functions=$(cat ${OUTPUT}/cognitive-complexity.log 2>/dev/null | wc -l)

          JSON="{ \"repo\": \"${{ inputs.repo }}\", \"scan-date\": \"$now\", \"functions\": $functions, \"bugs\": ["

          for f in $(find . -type f -name '*.html' | grep report); do
            bugfound=1
            bugtype=$(parse_info $f BUGTYPE)
            bugcategory=$(parse_info $f BUGCATEGORY)
            bugfile=$(parse_info $f BUGFILE)
            bugline=$(parse_info $f BUGLINE)
            bugdescription=$(parse_info $f BUGDESC)
            bugfunction=$(parse_info $f FUNCTIONNAME)

            JSON+="{"
            JSON+=" \"category\": \"$bugcategory\","
            JSON+=" \"type\": \"$bugtype\","
            JSON+=" \"file\": \"$bugfile\","
            JSON+=" \"line\": $bugline,"
            JSON+=" \"function\": \"$bugfunction\","
            JSON+=" \"description\": \"$bugdescription\""
            JSON+=" },"
          done

          if [ -f ${OUTPUT}/cognitive-complexity.log ]; then
            while read -r line; do
              bugtype="Cognitive complexity"
              bugcategory="Readability"
              bugfile=$(echo $line | awk '{ print $1 }' | awk -F":" '{ print $1 }')
              bugline=$(echo $line | awk '{ print $1 }' | awk -F":" '{ print $2 }')
              bugfunction=$(echo $line | awk '{ print $4 }' | tr -d "'" )
              bugdescription=$(echo $line | awk '{ print $9 }')

              [[ $bugdescription -lt 25 ]] && continue

              bugfound=1

              JSON+="{"
              JSON+=" \"category\": \"$bugcategory\","
              JSON+=" \"type\": \"$bugtype\","
              JSON+=" \"file\": \"$bugfile\","
              JSON+=" \"line\": $bugline,"
              JSON+=" \"function\": \"$bugfunction\","
              JSON+=" \"description\": \"$bugdescription\""
              JSON+=" },"
            done < ${OUTPUT}/cognitive-complexity.log
          fi

          if [ $bugfound -eq 1 ]; then
            JSON="${JSON%?}" # Remove last ","
          fi

          JSON+="]"
          JSON+="}"

          echo $JSON > $OUTPUT/result.json

          if [ $bugfound -eq 0 ]; then
            exit 0
          fi

          jq '.bugs[].category' $OUTPUT/result.json | sort | uniq -c > $OUTPUT/bug-categories.txt
          jq '.bugs[].type' $OUTPUT/result.json | sort | uniq -c > $OUTPUT/bug-types.txt

          JSON="${JSON%?}" # Remove last "}"
          JSON+=","

          JSON+="\"categories\": ["

          while read -r line; do
            c=$(echo $line | awk -F ' ' '{ print $1 }')
            d=$(echo $line | awk -F '"' '{ print $2 }')

            JSON+="{\"category\": \"$d\", \"count\": $c },"
          done < $OUTPUT/bug-categories.txt

          JSON="${JSON%?}" # Remove last ","
          JSON+="],\"types\":["

          while read -r line; do
            c=$(echo $line | awk -F ' ' '{ print $1 }')
            d=$(echo $line | awk -F '"' '{ print $2 }')

            JSON+="{\"type\": \"$d\", \"count\": $c },"
          done < $OUTPUT/bug-types.txt

          JSON="${JSON%?}" # Remove last ","
          JSON+="]}"
          echo $JSON > $OUTPUT/result.json

      - name: Adding scan summary to Github markdown
        if: ${{ always() }}
        env:
          SREPO: ${{ steps.vars.outputs.SREPO }}
        run: |
          cd $GITHUB_WORKSPACE
          bugs=$(jq '.bugs | length' $SREPO/result.json)
          functions=$(jq '.functions | length' $SREPO/result.json)
          if [ ${bugs} -gt 0 ]; then
            echo "### ${{ inputs.repo }}: ${bugs} bugs found" >> $GITHUB_STEP_SUMMARY
            echo "### Functions: $functions" >> $GITHUB_STEP_SUMMARY
            echo "#### Bug categories" >> $GITHUB_STEP_SUMMARY
            echo "| Category | Count |" >> $GITHUB_STEP_SUMMARY
            echo "| --- | --- |" >> $GITHUB_STEP_SUMMARY
            jq '.categories[] | "| \(.category) | \(.count) |"' $SREPO/result.json | tr -d '"' >> $GITHUB_STEP_SUMMARY
            echo "#### Bug types" >> $GITHUB_STEP_SUMMARY
            echo "| Type | Count |" >> $GITHUB_STEP_SUMMARY
            echo "| --- | --- |" >> $GITHUB_STEP_SUMMARY
            jq '.types[] | "| \(.type) | \(.count) |"' $SREPO/result.json | tr -d '"' >> $GITHUB_STEP_SUMMARY
          fi

      - name: compress result
        if: ${{ always() }}
        run: |
          tar -czvf ${{ steps.vars.outputs.SREPO }}.${{ github.job }}.tar.gz --remove-files ${{ steps.vars.outputs.SREPO }}

      - name: save results
        if: ${{ always() }}
        uses: actions/upload-artifact@v3
        with:
          retention-days: 1
          name: ${{ steps.vars.outputs.SREPO }}.${{ github.job }}
          path: ${{ steps.vars.outputs.SREPO }}.${{ github.job }}.tar.gz
